\newpage
\section*{Реализация} 

Составим некоторый алгоритм решения нашей задачи. Напомним, что никаких оптимизаций в алгоритме не проводилось, то есть расчеты велись <<влоб>>. Так как это никоим образом не помешает анализу и сравнению производительности процессора и графического ускорителя, а также даст некоторую верхнюю практическую оценку вычисления задачи. 

\subsection*{Пересечение отрезка и многоугольника}

Задача определения пересечения отрезка и многоугольника разбивается на следующие этапы:

1. Определить точку пересечения $ M $ плоскости многоугольника и прямой, содержащей отрезок.

2. Находится ли точка пересечения $ M $ внутри многоугольника.

3. Находится ли точка пересечения $ M $ внутри отрезка.

Описанные выше задачи решаются стандартными методами аналитической геометрии \cite{geometry}

\subsection*{Первичные грани}

1. Берем полигон модели $\alpha$.

2. Определяем её геометрический центр -- точку $P$.

3. Для всех граней модели проверяем, пересекает ли её отрезок $PL$ (кроме исходного полигона $\alpha$, центром которого является $P$), где $L$ -- источник электромагнитного излучения.

4. В случае отсутствия таких граней, помечаем исходный полигон $\alpha$ как первичный и рассчитываем какую энергию в секунду получает наша поверхность
\begin{gather}
  P_{in} = \frac{P_0 S cos\phi}{4 \pi R^2},
\end{gather}
где $P_0$ -- мощность исходного источника излучения $L$, $\phi$ -- угол между вектором $\vec {LP}$ и нормалью $\vec n$, направленной в сторону $L$, расстояние $R = PL$, а $S$ -- площадь полигона.

5. Повторяем шаги 1-4 для всех полигонов поверхности.

Параллелизация на графическом ускорителе выполнялась на всех уровнях: как на внешнем цикле 1-4, так и на внутреннем 3. Причем внутренний цикл распределялся между нитями одного блока, а внешний -- между блоками. При выполнении алгоритма на ускорителе модель космического корабля хранилась в глобального типа памяти. 

\subsection*{Вторичные грани}

1. Проведем расчеты первично-освещенных граней.

2. Для каждой первичной грани $\alpha$ выполним следующие шаги:

3. Определим центр первично-освещенной грани $P$.

4. Для каждого полигона модели $\beta$ с геометрическим центром $V$, если не существует элементов моделей, пересекающих отрезок $PV$, будем считать его вторично-освещенным (аналогично как при определении первичных).

5. Мощность, получаемая вторично-освещенным полигоном от первично-освещенного фрагмента в этом случае рассчитываем по формуле
\begin{gather}
  \Delta P'_{in} = \frac{P_{in} f S' cos\phi'}{2 \pi R'^2},
\end{gather}
где $ P_{in} $ -- получаемая мощность первичной грани от источника излучения, $ f $ -- двулучевая функция отражения ($ P_{in} \cdot f = P_{out} $ в направлении проверяемой грани), $ S' $ -- площадь полигона $ \beta $, расстояние $R' = PV$, угол $\phi'$ между вектором $\vec {PV}$ и нормалью $\vec n'$ к полигону $\beta$, направленной в сторону точки $P$.

Выполнив весь внешний цикл 2-5 получим 
\begin{gather}
  P'_{in} = \sum_j \Delta P'_{in_j},
\end{gather}
то есть влияние всех первичных граней сложится.

Параллелизация выполнялась на всех уровнях: на внешнем цикле 2-5, на среднем 4 и на внутреннем 4. При реализации на CUDA внутренний цикл делился между нитями одного блока. Остальные циклы (средний и внешний) делились между блоками упорядоченными в двумерную сетку. Аналогично, как и в предыдущем алгоритме, модель при выполении программы на видеокарте, хранилась в глобальной памяти. 

Если грань по итогом работы двух процедур не относилась ни к первичной, ни к вторичной, то она помечалась особым цветом. 

На основе рассчитанного освещения граней строилась сфера вокруг модели -- сфера освещения. Расчет получаемой мощности полигонами сферы проводился аналогичными указанными выше способами. 

Также, программа строит несколько проекций сфер на плоскость и получает изображение.
